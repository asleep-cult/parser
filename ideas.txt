A compiled language that includes the benefits of interpreted languages.
The compilation process is as follows Source -> Tokens -> AST -> Bytecode ->
Machine Code.

Braces are used to define blocks, named blocks can be overloaded
in their scope. Example:

```
function namedBlock() {
        try {
                doSomething()
        }
        catch;
}
```
The example above is equivalent to `catch {}`, the block is optional.

Qualifiers are used to change the meaning of something, some built-in block
qualifiers are function, class, interface, compconst and overridden. Some
built-in type qualifiers are immutable, ...? .

Block guards essentially guard a block from being fully created until the
block is initiated, this is useful for generics. Example:

```
class GuardedBlock<T: Type>
{

}

T = GuardedBlock<Int>
```

The `@` symbol is a request directly to the compiler, Example: `@import("foo")`

Ideologies:
Readability matters but so does performance.
Special cases turn developers into second-class citizens.
Meaning that overloadability is important but no code should behave unexpectedly.
Undefined behavior is never good, instead an exception should be raised.
High level interfaces should be provided but low level interfaces should never be restricted.
Reinventing the wheel is okay, innovation needs to happen some day.
