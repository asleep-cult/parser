statically typed or dynamically typed?

I'd like this "language" to be statically typed but I'd like to provide
an interface to dynamic types through an Any type. Any will be
compatible with all operators and are assumed to have all properties but
this can only be proven at runtime.

how do types work?

Types contain information needed to get object properties, when a new struct
instance is created the compiler creates an array of struct member names.
The compiler can then write an instruction that tells the runtime to get the
object from the heap at the index of the name in the array + the index of
the struct instance itself in the heap. The Any type is different, instead of
telling to runtime to get a specific object on the heap, it must
store its actual type and maintain a hash-map of struct members to the memory
locations of objects. It will then tell the runtime to perform a hash-map
lookup for the name, if this lookup is unsuccessful the runtime will throw
an error. When the Any type is used only the runtime is capable of
determining if the property exists, when a real type is used the runtime
knows the type exists and doesn't have to deal with the overhead of a
hash-map lookup.

compiled or interpreted?

There will be multiple implementations but the end goal is for the
"official" implementation to use a JIT compiler, an interpreted implementation
will likely come first.

garbage collection?

This "language" will use a mark-sweep-compact garbage collection algorithm,
everything will be allocated on a heap and referenced by the stack. All objects
on the heap will have a bit determining if it's unreachable, the runtime will
search the stack for all objects on the heap and mark the unreachable bit
if it wasn't found. The runtime will then sweep the heap of unreachable
objects and compact the heap so that there aren't gaps where live objects
once lived (live objects on top free space on the bottom).

basic syntax?

The idea is named blocks of code that can be decorated with block decorators

```
function namedBlock(int x) void {
        Integer foo = 9;
}
```

here function is the block decorator

```
struct NamedBlock {
        Integer foo;
}
```

here struct is the block decorator

```
private class NamedBlock {
}
```

here there a multiple block decorators... private and class.
These aren't keywords... just built-in decorators :^)
